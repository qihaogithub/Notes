[教程](https://blog.csdn.net/qq_51137480/article/details/133858816?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-133858816-blog-130511311.235^v43^pc_blog_bottom_relevance_base7&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

## 泳道+flex实现
通过将一组图片对象分布到指定数量的泳道中实现，每个泳道使用 [Flex布局](https://so.csdn.net/so/search?q=Flex%E5%B8%83%E5%B1%80&spm=1001.2101.3001.7020)，泳道中的图片项高度根据图片对象的属性进行动态设置，以呈现瀑布流效果

```JavaScript
<template>
    <!-- 创建外部容器用于包装瀑布流内容 -->
    <div class="waterfall-container">
      <!-- 创建每个泳道，lanes 数组中的每个元素都代表一个泳道 -->
      <div v-for="(lane, index) in lanes" :key="index" class="lane" :style="{ width: laneWidth + '%' }">
        <!-- 创建每个瀑布流项，flowItem 包含图片的内容和高度 -->
        <div v-for="(flowItem, flowIndex) in lane" :key="flowIndex" class="item"
          :style="{ height: flowItem.height + 'px' }">
          {{ flowItem.content }}
        </div>
      </div>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        images: [
          // 定义一组图片对象，每个对象包含图片的内容和高度
          { content: 'Item 1', height: 100 },
          { content: 'Item 2', height: 150 },
          { content: 'Item 3', height: 120 },
          { content: 'Item 4', height: 130 },
          { content: 'Item 5', height: 110 },
          { content: 'Item 6', height: 140 },
          { content: 'Item 7', height: 150 },
          { content: 'Item 8', height: 120 },
          { content: 'Item 9', height: 130 },
          // 可以添加更多图片项，每个项的高度可以不同
        ],
        laneCount: 4, // 指定泳道的数量
      };
    },
    computed: {
      lanes() {
        // 计算属性，用于将图片分布到各个泳道
        const lanes = new Array(this.laneCount).fill().map(() => []);
  
        this.images.forEach((image, index) => {
          // 根据图片数量和泳道数量计算每张图片应该放在哪个泳道
          const laneIndex = index % this.laneCount;
          lanes[laneIndex].push(image);
        });
  
        return lanes;
      },
      laneWidth() {
        // 计算泳道的宽度百分比，以确保它们平均分布在容器中
        return 100 / this.laneCount;
      },
    },
  };
  </script>
  
  <style>
  .waterfall-container {
    display: flex;
    flex-wrap: wrap;
    /* 使用 Flex 布局并允许泳道换行 */
  }
  
  .lane {
    display: flex;
    /* 泳道中的图片从上到下排列 */
    flex-direction: column;
  }
  
  .item {
    background-color: blanchedalmond;
    padding: 5px;
    box-sizing: border-box;
    margin: 5px;
    /* 设置图片项的样式，包括间隙 */
  }
  </style>
  

```

<<<<<<< HEAD


## 属性

[当前可用的属性重现了原始砌体插件](http://masonry.desandro.com/options.html)中的大部分属性：

- `item-selector=".item"`- 列表元素 DOM 项目选择器；
- `transition-duration="0.3s`- 过渡的持续时间；
- `column-width="#test"`- 列宽的元素选择器。可以是选择器字符串或数字；
- `origin-left="false"`- 默认设置为将元素分组到右侧，而不是左侧；
- `origin-top="false"`- 默认将元素分组到底部而不是顶部；
- `stamp=".stamp"`- 指定布局中标记哪些元素；
- `gutter=".gutter-block-selector"`- 指定 [项目元素之间的水平空间]。可以是选择器字符串或数字。（[https://masonry.desandro.com/options.html#gutter](https://masonry.desandro.com/options.html#gutter)）。将 gutter 设置为元素或选择器字符串以使用元素的外部宽度；
- `fit-width="true"`- 设置容器的宽度以适合可用的列数；
- `horizontal-order="true"`- 布局项目以（大部分）保持水平从左到右的顺序；
- `stagger="0.03s"`- 交错项目转换，因此项目会一个接一个地逐步转换。设置为 CSS 时间格式“0.03s”，或设置为毫秒数 30。
- `destroy-delay="0"`- 容器被销毁时卸载砌体前等待的时间（以毫秒为单位）`masonry.destroy()`。这在页面/路由转换期间很有用，可确保转换过程中布局一致。

如果您需要手动触发砌体布局重绘（例如，如果您的图块元素数量或内容已更改），您现在可以使用 `this.$redrawVueMasonry('containerId')` 方法。从 [0.11.8](https://github.com/shershen08/vue-masonry/pull/89) 开始，您可以传递要触发重绘的块的 ID。




## 我的代码

```
<template>

  <div>

    <!-- 分组展示标签 -->

    <div class="sift">

      <div>

        <div class="tags" v-for="(tags, groupName) in groupedTags" :key="groupName">

          <p>{{ groupName }}</p>

          <button v-for="tag in tags" :key="tag" :class="{ active: selectedTags[groupName] === tag }" class="button"

            @click="toggleTagSelection(tag, groupName)">

            {{ tag }}

          </button>

        </div>

      </div>

      <button class="button quanbu" @click="clearFilter">清除筛选</button>

    </div>

  

    <div class="asonry" v-masonry transition-duration="0s" gutter="10" fit-width="true" horizontal-order="true" >

      <div v-masonry-tile v-for="image in paginatedImages" :key="image.folderName" class="image-item"

        @click="showImageDetails(image)">

        <img :src="image.imageUrlThumbnail || image.imageUrl" :alt="image.folderName" />

      </div>

      <div ref="loadMoreTrigger" class="load-more-trigger"></div>

    </div>

  

    <div v-if="selectedImage" class="overlay" @click.self="closeImageDetails">

      <div class="overlay-content">

        <button class="close-btn" @click="closeImageDetails">X</button>

        <img :src="selectedImage.imageUrl" :alt="selectedImage.folderName" class="overlay-image" />

        <div class="image-info">

          <div class="list-container">

            <div>名称:</div>

            <div>{{ selectedImage.name }}</div>

          </div>

          <div class="list-container">

            <div>修改时间:</div>

            <div>{{ formatTime(selectedImage.modificationTime) }}</div>

          </div>

          <div class="list-container" v-if="selectedImage.tags && selectedImage.tags.length > 0">

            <div>标签:</div>

            <div>{{ selectedImage.tags.join(", ") }}</div>

          </div>

        </div>

      </div>

    </div>

  </div>

</template>

  

<script setup>

import { ref, computed, onMounted, watch } from "vue";

import axios from "axios";

import masonry from "masonry-layout";

  

const images = ref([]);

const selectedImage = ref(null);

const selectedTags = ref({}); // 用于存储按组选择的标签

  

const currentPage = ref(1);

const imagesPerPage = 20; // 每页加载的图片数量

const loadMoreTrigger = ref(null);

  
  
  

onMounted(() => {

  fetchImagesInfo();

  // 设置 "叫叫" 标签默认选中

  if (tagGroups.品牌.includes("叫叫")) {

    selectedTags.value.品牌 = "叫叫";

  }

  setupIntersectionObserver();

});

  

async function fetchImagesInfo() {

  try {

    const response = await axios.get(

      "https://uiweb.oss-cn-chengdu.aliyuncs.com/images/imagesInfo.json"

    );

    images.value = response.data;

  } catch (error) {

    console.error("Error fetching images info:", error);

  }

}

  

function setupIntersectionObserver() {

  const observer = new IntersectionObserver((entries) => {

    if (entries[0].isIntersecting) {

      loadMoreImages();

    }

  });

  if (loadMoreTrigger.value) {

    observer.observe(loadMoreTrigger.value);

  }

}

  

function loadMoreImages() {

  currentPage.value += 1;

}

  

function showImageDetails(image) {

  selectedImage.value = image;

  // 隐藏主滚动条

  document.body.style.overflow = "hidden";

}

  

function closeImageDetails() {

  selectedImage.value = null;

  // 恢复主滚动条

  document.body.style.overflow = "";

}

  

// 格式化时间戳为日期和时间

function formatTime(timestamp) {

  const date = new Date(timestamp);

  return date.toLocaleString();

}

  

// 标签分组规则

const tagGroups = {

  品牌: [

    "叫叫",

    "火花思维",

    "少年得到",

    "喜马拉雅儿童",

    "洋葱学院",

    "百词斩",

    "多领国",

    "KaDa阅读",

    "ahakid",

    "洪恩分级阅读",

  ],

  机型: ["pad", "手机"],

  其他: [],

};

  

// 计算属性，用于筛选图片

const filteredImages = computed(() => {

  const selectedGroupTags = Object.values(selectedTags.value);

  if (selectedGroupTags.length === 0) {

    return images.value;

  }

  return images.value.filter((image) =>

    selectedGroupTags.every((tag) => image.tags && image.tags.includes(tag))

  );

});

  

const paginatedImages = computed(() => {

  const startIndex = (currentPage.value - 1) * imagesPerPage;

  return filteredImages.value.slice(0, startIndex + imagesPerPage);

});

  

// 获取唯一标签列表

const uniqueTags = computed(() => {

  const tags = new Set();

  images.value.forEach((image) => {

    if (image.tags) {

      image.tags.forEach((tag) => tags.add(tag));

    }

  });

  return Array.from(tags);

});

  

// 将标签分组

const groupedTags = computed(() => {

  const groups = {};

  

  // 初始化分组

  for (const groupName in tagGroups) {

    groups[groupName] = [];

  }

  

  // 添加标签到相应的分组

  uniqueTags.value.forEach((tag) => {

    let added = false;

    for (const groupName in tagGroups) {

      if (tagGroups[groupName].includes(tag)) {

        groups[groupName].push(tag);

        added = true;

        break;

      }

    }

    // 如果没有匹配的分组，则加入“其他”分组

    if (!added) {

      if (!groups["其他"]) {

        groups["其他"] = [];

      }

      groups["其他"].push(tag);

    }

  });

  

  return groups;

});

  

// 切换标签选择的方法

function toggleTagSelection(tag, groupName) {

  if (selectedTags.value[groupName] === tag) {

    delete selectedTags.value[groupName];

  } else {

    selectedTags.value[groupName] = tag;

  }

  // 重置分页

  currentPage.value = 1;

}

  

// 清除筛选

function clearFilter() {

  selectedTags.value = {};

  // 重置分页

  currentPage.value = 1;

}

</script>

  

<style scoped>

.asonry {

  margin: 0 auto;

  background-color: #42b983;

  

  /* height: 100% !important; */

}

  

.image-item {

  /* break-inside: avoid;

  margin-bottom: 1em;

  cursor: pointer; */

  /* float: left; */

  /* padding: 10px; */

  /* margin: 0 auto; */

;

  

  img {

    width: 200px;

  }

}

  

.image-item img {

  width: 100%;

  display: block;

  border-radius: 5px;

}

  

.image-item {

  break-inside: avoid;

  margin-bottom: 1em;

  cursor: pointer;

  

  box-shadow: 0 0.25em 3.125em #00000014;

}

  

.image-item img {

  width: 100%;

  display: block;

  border-radius: 5px;

}

  

.overlay {

  position: fixed;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  background-color: rgba(0, 0, 0, 0.8);

  display: flex;

  justify-content: center;

  align-items: flex-start;

  overflow-y: auto;

}

  

.overlay-content {

  background-color: white;

  padding: 20px;

  border-radius: 5px;

  max-width: 90%;

  position: relative;

  display: flex;

  margin: 32px auto 32px auto;

  justify-content: center;

  border-radius: 20px;

  height: auto;

  /* 自动根据内容调整高度 */

  width: max-content;

  /* 自动根据内容调整宽度 */

}

  

.overlay-image {

  width: 640px;

  height: auto;

  /* Height will adjust automatically */

  object-fit: contain;

  /* 确保图片不会变形 */

  border-radius: 20px;

  cursor: zoom-in;

}

  

.image-info {

  display: flex;

  flex-direction: column;

  width: 400px;

  padding: 32px;

  margin-top: 16px;

}

  

.image-info .list-container {

  display: flex;

  height: 24px;

  margin: 4px 0;

  align-items: center;

}

  

.sift {

  display: flex;

  justify-content: space-between;

}

  

.close-btn {

  position: absolute;

  top: 10px;

  right: 10px;

  background: none;

  border: none;

  font-size: 1 5em;

  cursor: pointer;

}

  

.tags {

  display: flex;

  flex-wrap: wrap;

  gap: 10px;

  align-items: center;

  padding: 4px 16px;

}

  

.button {

  background-color: #f6f6f6;

  border: none;

  color: #333;

  /* padding: 4px 16px; */

  height: 32px;

  text-align: center;

  text-decoration: none;

  display: inline-block;

  font-size: 16px;

  cursor: pointer;

  border-radius: 5px;

}

  

button.active {

  background-color: #42b983;

  color: white;

}

  

.quanbu {

  height: 32px;

  margin: 4px 16px;

}

  

.load-more-trigger {

  height: 1px;

}

</style>
```
=======
##  第三方库
[[vue-masonry]]
>>>>>>> origin/master
