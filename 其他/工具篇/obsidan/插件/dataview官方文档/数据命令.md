

数据视图查询可以由不同的命令组成。命令按顺序执行，并且可以有重复的命令 (例如，多个 WHERE 块或多个 GROUPBY 块)。

来自
--

FROM 语句确定最初将收集哪些页并传递给其他命令以进一步筛选。您可以从任何源中进行选择，当前指的是文件夹、标记或传入/传出链接。

*   标签: 要从标签 (及其所有子标签)中进行选择，使用 FROM # 标签。
*   文件夹: 要从一个文件夹 (及其所有子文件夹)中进行选择，请使用 FROM“文件夹”。
*   Single Files: 要从单个文件中进行选择，请使用 FROM“ path/To/file”。
*   链接: 可以选择指向文件的链接，也可以选择来自文件的所有链接。
*   要获取所有链接到\[\[注\]\]的页面，请使用 FROM \[\[\[注\]\]。
*   要获取所有链接 FROM \[\[ note \]\](即该文件中的所有链接)的页面，请使用 FROM 传出 (\[\[ note \]\])。

您可以组合这些过滤器，以便使用和或获得更高级的源。

*   例如，# 标签和“文件夹”将返回文件夹中的所有页面和 # 标签。
*   \[\[食物\]\]或\[\[锻炼\]\]会给出任何链接到\[\[食物\]\]或\[\[锻炼\]\]的页面。

您也可以“否定”源，以获得任何不匹配的源使用-:

*   \# tag 将排除具有给定标记的文件。
*   \# 标记和-“文件夹”将只包括标记为 # 标记的文件，这些文件不在“文件夹”中。

哪里
--

筛选字段上的页面。只有子句计算结果为 true 的页面才会被生成。

1.  获取在过去 24 小时内修改过的所有文件:
    
    `LIST  WHERE  file.mtime  >=  date(today)  -  dur(1  day)` 
    
2.  查找所有未标记为已完成且已超过一个月的项目:

```
LIST  
FROM  #projects
WHERE  !Completed  AND  
`
```

算是吧
---

按一个或多个字段对所有结果排序。

`SORT date [ASCENDING/DESCENDING/ASC/DESC]` 

还可以提供多个字段进行排序。将根据第一个字段进行排序。然后，如果出现绑定，则将使用第二个字段对绑定字段进行排序。如果仍然存在平局，第三类将解决它，以此类推。

`SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC]` 

群体
--

将所有结果分组到一个域中。每个唯一的字段值生成一行，该字段有两个属性: 一个对应于要分组的字段，另一个行数组字段包含所有匹配的页。

`GROUP BY field
GROUP BY (computed_field) AS name ` 

为了使处理行数组更容易，Dataview 支持字段“ swizzling”。如果您希望对行数组中的每个对象进行字段测试，那么 rows. Test 将自动从行中的每个对象获取测试字段，从而生成一个新数组。然后，您可以在结果数组上应用诸如 sum ()或 plat ()之类的聚合运算符。

压平
--

在每一行中压平一个数组，为数组中的每个条目生成一个结果行。

`FLATTEN field
FLATTEN (computed_field) AS name ` 

例如，将每个文献注释中的作者字段展开，给出每个作者一行:

质疑

`TABLE  authors  FROM  #LiteratureNote
FLATTEN  authors ` 

输出

当有一个深度嵌套的列表，您希望更容易地使用它时，就可以很好地使用它。例如，file. List 或 file. Asks。注意更简单的查询，尽管最终结果略有不同 (分组与非分组)。您可以使用 GROUP BY file. Link 来获得相同的结果，但是需要使用前面描述的 rows. T. Text。

`table T.text as "Task Text"
From "Scratchpad"
Flatten file. Tasks as T
where T.text ` 

`table filter(file.tasks.text, (t) => t) as "Task Text"
From "Scratchpad"
where file. Tasks. Text ` 

FLATTEN 使得在嵌套列表上操作变得更加容易，因为您可以在嵌套列表上使用更简单的条件，而不是使用 map ()或 filter ()之类的函数。

限制
--

将结果限制为最多 N 个值。

命令是按照它们的写入顺序处理的，因此下面对已经受到限制的结果进行了排序:

`LIMIT 5
SORT date ASCENDING `